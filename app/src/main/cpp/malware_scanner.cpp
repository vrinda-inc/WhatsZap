#include "malware_scanner.h"
#include "native-lib.h"
#include <fstream>
#include <sstream>
#include <sys/stat.h>
#include <unistd.h>
#include <algorithm>
#include <cstring>
#include <iomanip>
#include <ctime>
#include <vector>
#include <memory>

const std::vector<std::string> MalwareScanner::SUSPICIOUS_PERMISSIONS = {
    "android.permission.SEND_SMS",
    "android.permission.RECEIVE_SMS",
    "android.permission.READ_SMS",
    "android.permission.READ_CONTACTS",
    "android.permission.READ_PHONE_STATE",
    "android.permission.ACCESS_FINE_LOCATION",
    "android.permission.ACCESS_COARSE_LOCATION",
    "android.permission.RECORD_AUDIO",
    "android.permission.CAMERA",
    "android.permission.WRITE_EXTERNAL_STORAGE",
    "android.permission.READ_EXTERNAL_STORAGE"
};

const std::vector<std::string> MalwareScanner::SUSPICIOUS_PACKAGES = {
    "com.malware.example",
    "com.virus.sample"
};

MalwareScanner::MalwareScanner() {
}

MalwareScanner::~MalwareScanner() {
}

ScanResult MalwareScanner::scanApk(const std::string& apkPath) {
    ScanResult result;
    long startTime = time(nullptr) * 1000; // milliseconds
    
    try {
        // Check if file exists
        struct stat fileStat;
        if (stat(apkPath.c_str(), &fileStat) != 0) {
            result.threats.push_back("File not found or inaccessible");
            result.scanDuration = (time(nullptr) * 1000) - startTime;
            return result;
        }
        
        // Check file size
        long fileSize = fileStat.st_size;
        double fileSizeMB = fileSize / (1024.0 * 1024.0);
        
        if (fileSizeMB < 0.1) {
            result.threats.push_back("Suspiciously small APK file");
            result.confidence += 10;
        } else if (fileSizeMB > 100) {
            result.threats.push_back("Unusually large APK file");
            result.confidence += 5;
        }
        
        // Calculate simple file hash (not MD5, but sufficient for identification)
        std::string fileHash = calculateSimpleHash(apkPath);
        LOGI("APK Hash: %s", fileHash.c_str());
        
        // Try to read APK as ZIP file using basic file operations
        // Since libzip may not be available, we'll use a simpler approach
        std::ifstream apkFile(apkPath, std::ios::binary);
        if (!apkFile.is_open()) {
            result.threats.push_back("Failed to open APK file (corrupted or invalid)");
            result.confidence += 30;
            result.scanDuration = (time(nullptr) * 1000) - startTime;
            return result;
        }
        
        bool manifestFound = false;
        int suspiciousPermCount = 0;
        
        // Read file and search for AndroidManifest.xml content
        // This is a simplified approach - in production, you'd want proper ZIP parsing
        std::string fileContent;
        apkFile.seekg(0, std::ios::end);
        fileContent.reserve(apkFile.tellg());
        apkFile.seekg(0, std::ios::beg);
        fileContent.assign((std::istreambuf_iterator<char>(apkFile)),
                          std::istreambuf_iterator<char>());
        apkFile.close();
        
        // Search for manifest indicators in the binary content
        // Look for common Android manifest strings
        std::string lowerContent = fileContent;
        std::transform(lowerContent.begin(), lowerContent.end(), lowerContent.begin(), ::tolower);
        
        if (lowerContent.find("androidmanifest") != std::string::npos) {
            manifestFound = true;
            
            // Try to extract manifest-like content (this is simplified)
            // In a real implementation, you'd parse the binary XML properly
            size_t manifestPos = lowerContent.find("androidmanifest");
            if (manifestPos != std::string::npos) {
                // Extract a chunk around the manifest for analysis
                size_t start = manifestPos > 1000 ? manifestPos - 1000 : 0;
                size_t length = std::min(static_cast<size_t>(50000), fileContent.length() - start);
                std::string manifestSection = fileContent.substr(start, length);
                
                suspiciousPermCount = analyzeManifest(manifestSection, result.threats);
                result.confidence += suspiciousPermCount * 5;
            }
        }
        
        // Check for suspicious file names/strings in the binary
        if (lowerContent.find("malware") != std::string::npos ||
            lowerContent.find("virus") != std::string::npos ||
            lowerContent.find("trojan") != std::string::npos ||
            lowerContent.find("exploit") != std::string::npos) {
            result.threats.push_back("Suspicious content detected in APK");
            result.confidence += 20;
        }
        
        if (!manifestFound) {
            result.threats.push_back("AndroidManifest.xml not found or corrupted");
            result.confidence += 30;
        }
        
        // Ensure minimum scan time of 10 seconds
        long elapsed = (time(nullptr) * 1000) - startTime;
        long minScanTime = 10000; // 10 seconds
        if (elapsed < minScanTime) {
            usleep((minScanTime - elapsed) * 1000);
        }
        
        result.isMalicious = result.confidence >= 30;
        result.confidence = std::min(100, result.confidence);
        result.scanDuration = (time(nullptr) * 1000) - startTime;
        
        if (result.threats.empty() && !result.isMalicious) {
            result.threats.push_back("No threats detected");
        }
        
    } catch (const std::exception& e) {
        LOGE("Exception during scan: %s", e.what());
        result.threats.push_back("Scan error: " + std::string(e.what()));
    }
    
    return result;
}

int MalwareScanner::analyzeManifest(const std::string& manifestContent, 
                                   std::vector<std::string>& threats) {
    int suspiciousCount = 0;
    
    // Check for suspicious permissions
    for (const auto& permission : SUSPICIOUS_PERMISSIONS) {
        if (manifestContent.find(permission) != std::string::npos) {
            suspiciousCount++;
            threats.push_back("Suspicious permission requested: " + permission);
        }
    }
    
    // Check for suspicious package names
    for (const auto& pkg : SUSPICIOUS_PACKAGES) {
        if (manifestContent.find(pkg) != std::string::npos) {
            threats.push_back("Known malicious package detected: " + pkg);
            suspiciousCount += 5;
        }
    }
    
    return suspiciousCount;
}

std::string MalwareScanner::calculateSimpleHash(const std::string& filePath) {
    std::ifstream file(filePath, std::ios::binary);
    if (!file) {
        return "";
    }
    
    // Simple hash calculation (not cryptographically secure, but good enough for identification)
    unsigned long hash = 5381;
    char c;
    
    // Read first 64KB for quick hash
    char buffer[65536];
    size_t bytesRead = 0;
    while (file.read(buffer, sizeof(buffer)) && bytesRead < 65536) {
        size_t count = file.gcount();
        for (size_t i = 0; i < count; i++) {
            hash = ((hash << 5) + hash) + buffer[i]; // hash * 33 + c
        }
        bytesRead += count;
    }
    
    std::ostringstream oss;
    oss << std::hex << hash;
    return oss.str();
}

